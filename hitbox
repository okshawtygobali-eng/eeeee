-- [[ HITBOX EXTENDER CORE - FIXED FOR FREEZING ]]
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

local LimbExtender = {}
LimbExtender.__index = LimbExtender

local DEFAULTS = {
    TOGGLE = "L",
    TARGET_LIMB = "HumanoidRootPart",
    LIMB_SIZE = 5,
    LIMB_TRANSPARENCY = 0.5,
    LIMB_CAN_COLLIDE = false, -- STAYS FALSE TO PREVENT STICKING
    TEAM_CHECK = false,
    FORCEFIELD_CHECK = false,
}

function LimbExtender.new(userSettings)
    local self = setmetatable({}, LimbExtender)
    self._settings = userSettings or DEFAULTS
    self._running = false
    self._connections = {}
    self._spoofTable = setmetatable({}, { __mode = "k" })
    
    local grm = getrawmetatable or nil
    local sro = setreadonly or make_writeable or nil
    if grm and sro then
        pcall(function()
            local mt = grm(game)
            if setreadonly then setreadonly(mt, false) else make_writeable(mt) end
            local oldIndex = mt.__index
            mt.__index = function(obj, key)
                if key == "Size" and not checkcaller() and self._spoofTable[obj] then
                    return self._spoofTable[obj]
                end
                return oldIndex(obj, key)
            end
            if setreadonly then setreadonly(mt, true) else make_readonly(mt) end
        end)
    end
    return self
end

function LimbExtender:Modify(char)
    if not char or not self._running then return end
    
    -- Use task.spawn so if one player's character is weird, it doesn't freeze the script
    task.spawn(function()
        local part = char:WaitForChild(self._settings.TARGET_LIMB, 5)
        if part and part:IsA("BasePart") then
            local size = self._settings.LIMB_SIZE
            local newSize = Vector3.new(size, size, size / 1.25)
            
            self._spoofTable[part] = part.Size
            
            -- [[ THE FIXES FOR FREEZING ]]
            part.CanCollide = false    -- Prevents hitting the floor
            part.Massless = true      -- Prevents the part from being too heavy to move
            part.Size = newSize
            part.Transparency = self._settings.LIMB_TRANSPARENCY
        end
    end)
end

function LimbExtender:Start()
    if self._running then return end
    self._running = true
    
    local function setup(plr)
        if plr == localPlayer then return end
        plr.CharacterAdded:Connect(function(c) 
            task.wait(0.1) -- Small delay to let physics load
            self:Modify(c) 
        end)
        if plr.Character then self:Modify(plr.Character) end
    end
    
    table.insert(self._connections, Players.PlayerAdded:Connect(setup))
    for _, p in ipairs(Players:GetPlayers()) do setup(p) end
end

function LimbExtender:Stop()
    self._running = false
    for _, v in ipairs(self._connections) do v:Disconnect() end
    self._connections = {}
    -- Parts will revert on respawn; clearing table stops the spoof
    for part in pairs(self._spoofTable) do self._spoofTable[part] = nil end
end

function LimbExtender:Get(k) return self._settings[k] end
function LimbExtender:Set(k, v) self._settings[k] = v end
function LimbExtender:Toggle(v) if v then self:Start() else self:Stop() end end

return LimbExtender
