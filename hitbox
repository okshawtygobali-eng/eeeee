-- [[ HITBOX EXTENDER CORE ]]
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

local LimbExtender = {}
LimbExtender.__index = LimbExtender

-- Standardized Settings for the UI to talk to
local DEFAULTS = {
    TOGGLE = "L",
    TARGET_LIMB = "HumanoidRootPart",
    LIMB_SIZE = 5,
    LIMB_TRANSPARENCY = 0.5,
    LIMB_CAN_COLLIDE = false,
    TEAM_CHECK = false,
    FORCEFIELD_CHECK = false,
    RESET_LIMB_ON_DEATH2 = false,
    USE_HIGHLIGHT = false, -- Deleted rendering logic for this to save FPS
}

function LimbExtender.new(userSettings)
    local self = setmetatable({}, LimbExtender)
    self._settings = userSettings or DEFAULTS
    self._running = false
    self._connections = {}
    self._spoofTable = setmetatable({}, { __mode = "k" }) -- Weak table for performance
    
    -- Metatable Hook (Bypass) with Safety Check
    local grm = getrawmetatable or nil
    local sro = setreadonly or make_writeable or nil
    if grm and sro then
        pcall(function()
            local mt = grm(game)
            if setreadonly then setreadonly(mt, false) else make_writeable(mt) end
            local oldIndex = mt.__index
            mt.__index = function(obj, key)
                if key == "Size" and not checkcaller() and self._spoofTable[obj] then
                    return self._spoofTable[obj]
                end
                return oldIndex(obj, key)
            end
            if setreadonly then setreadonly(mt, true) else make_readonly(mt) end
        end)
    end
    
    return self
end

function LimbExtender:Get(key) return self._settings[key] end

function LimbExtender:Set(key, value)
    self._settings[key] = value
    if self._running then self:Restart() end
end

function LimbExtender:Toggle(state)
    if state == nil then state = not self._running end
    if state then self:Start() else self:Stop() end
end

function LimbExtender:Modify(char)
    if not char or not self._running then return end
    local part = char:WaitForChild(self._settings.TARGET_LIMB, 5)
    if part and part:IsA("BasePart") then
        -- Wall Logic: sizeVal / 1.25
        local size = self._settings.LIMB_SIZE
        local newSize = Vector3.new(size, size, size / 1.25)
        
        self._spoofTable[part] = part.Size -- Hide real size
        part.Size = newSize
        part.Transparency = self._settings.LIMB_TRANSPARENCY
        part.CanCollide = self._settings.LIMB_CAN_COLLIDE
        part.Massless = true
    end
end

function LimbExtender:Start()
    self._running = true
    local function setup(plr)
        if plr == localPlayer then return end
        if self._settings.TEAM_CHECK and plr.Team == localPlayer.Team then return end
        
        plr.CharacterAdded:Connect(function(c) self:Modify(c) end)
        if plr.Character then self:Modify(plr.Character) end
    end
    
    table.insert(self._connections, Players.PlayerAdded:Connect(setup))
    for _, p in ipairs(Players:GetPlayers()) do setup(p) end
end

function LimbExtender:Stop()
    self._running = false
    for _, v in ipairs(self._connections) do v:Disconnect() end
    self._connections = {}
    -- Reset spoofing
    for part in pairs(self._spoofTable) do self._spoofTable[part] = nil end
end

function LimbExtender:Restart()
    self:Stop()
    self:Start()
end

-- THIS IS THE FIX: Returning the table so loadstring doesn't return nil
return LimbExtender
