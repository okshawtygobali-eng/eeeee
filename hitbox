local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

local DEFAULTS = {
	TOGGLE = "L",
	TARGET_LIMB = "HumanoidRootPart",
	LIMB_SIZE = 15,
	LIMB_TRANSPARENCY = 0.9,
	LIMB_CAN_COLLIDE = false,
	MOBILE_BUTTON = true,
	LISTEN_FOR_INPUT = true,
	TEAM_CHECK = true,
	FORCEFIELD_CHECK = true,
	RESET_LIMB_ON_DEATH2 = false,
	USE_HIGHLIGHT = true,
	DEPTH_MODE = "AlwaysOnTop",
	HIGHLIGHT_FILL_COLOR = Color3.fromRGB(255, 117, 24),
	HIGHLIGHT_FILL_TRANSPARENCY = 0.7,
	HIGHLIGHT_OUTLINE_COLOR = Color3.fromRGB(0,0,0),
	HIGHLIGHT_OUTLINE_TRANSPARENCY = 1,
}

local limbExtenderData = getgenv().limbExtenderData or {}
getgenv().limbExtenderData = limbExtenderData

if not limbExtenderData.SpoofedParts then
	limbExtenderData.SpoofedParts = setmetatable({}, { __mode = "k" })
end

-- [[ FIXED: Added Safety Check for Metatable Functions ]]
if not limbExtenderData.HookInstalled then
    local grm = getrawmetatable or nil
    local sro = setreadonly or make_writeable or nil
    
    if grm and sro then
        local mt = grm(game)
        if setreadonly then setreadonly(mt, false) else make_writeable(mt) end
        
        local oldIndex = mt.__index
        
        mt.__index = function(self, key)
            if key == "Size" and not checkcaller() then
                local savedSize = limbExtenderData.SpoofedParts[self]
                if savedSize then
                    return savedSize
                end
            end
            return oldIndex(self, key)
        end
        
        if setreadonly then setreadonly(mt, true) else make_readonly(mt) end
        limbExtenderData.HookInstalled = true
    else
        warn("Limb Extender: Your executor does not support getrawmetatable. Spoofing disabled.")
    end
end

if limbExtenderData.terminateOldProcess and type(limbExtenderData.terminateOldProcess) == "function" then
	limbExtenderData.terminateOldProcess("FullKill")
	limbExtenderData.terminateOldProcess = nil
end

if not limbExtenderData.ConnectionManager then
	limbExtenderData.ConnectionManager = loadstring(game:HttpGet('https://raw.githubusercontent.com/AAPVdev/modules/refs/heads/main/ConnectionManager.lua'))()
end

local ConnectionManager = limbExtenderData.ConnectionManager

-- Added pcall to getgc for safety
if not limbExtenderData._indexBypassDone then
	limbExtenderData._indexBypassDone = true
    pcall(function()
        if getgc then
            for _, obj in ipairs(getgc(true)) do
                local idx = rawget(obj, "indexInstance")
                if typeof(idx) == "table" and idx[1] == "kick" then
                    for _, pair in pairs(obj) do
                        pair[2] = function() return false end
                    end
                    break
                end
            end
        end
    end)
end

local function mergeSettings(user)
	local s = {}
	for k,v in pairs(DEFAULTS) do s[k] = v end
	if user then
		for k,v in pairs(user) do s[k] = v end
	end
	return s
end

local function watchProperty(instance, prop, callback)
	if not instance or type(prop) ~= "string" or type(callback) ~= "function" then return nil end
	local signal = instance:GetPropertyChangedSignal(prop)
	if signal and type(signal.Connect) == "function" then
		return signal:Connect(function() callback(instance) end)
	end
	return nil
end

local function makeHighlight(settings)
	local hiFolder =  game:GetService("ReplicatedStorage"):FindFirstChild("Limb Extender Highlights Folder")
	if not hiFolder then
		hiFolder = Instance.new("Folder")
		hiFolder.Name = "Limb Extender Highlights Folder"
		hiFolder.Parent = game:GetService("ReplicatedStorage")
	end
	local hi = Instance.new("Highlight")
	hi.Name = "LimbHighlight"

	if settings and settings.DEPTH_MODE and Enum.HighlightDepthMode[settings.DEPTH_MODE] then
		hi.DepthMode = Enum.HighlightDepthMode[settings.DEPTH_MODE]
	end
	if settings and settings.HIGHLIGHT_FILL_COLOR then hi.FillColor = settings.HIGHLIGHT_FILL_COLOR end
	if settings and settings.HIGHLIGHT_FILL_TRANSPARENCY then hi.FillTransparency = settings.HIGHLIGHT_FILL_TRANSPARENCY end
	if settings and settings.HIGHLIGHT_OUTLINE_COLOR then hi.OutlineColor = settings.HIGHLIGHT_OUTLINE_COLOR end
	if settings and settings.HIGHLIGHT_OUTLINE_TRANSPARENCY then hi.OutlineTransparency = settings.HIGHLIGHT_OUTLINE_TRANSPARENCY end
	hi.Enabled = true
	hi.Parent = hiFolder
	return hi
end

local PlayerData = {}
PlayerData.__index = PlayerData

function PlayerData.new(parent, player)
	local self = setmetatable({
		_parent = parent,
		player = player,
		conns = ConnectionManager.new(),
		highlight = nil,
		PartStreamable = nil,
		_charDelay = nil,
		_destroyed = false,
	}, PlayerData)

	if player and player.CharacterAdded and type(player.CharacterAdded.Connect) == "function" then
		self.conns:Connect(player.CharacterAdded, function(c) self:onCharacter(c) end, ("Player_%s_CharacterAdded"):format(player.Name))
	end
	local character = player and (player.Character or workspace:FindFirstChild(player.Name))
	self:onCharacter(character)
	return self
end

function PlayerData:saveLimbProperties(limb)
	local parent = self._parent
	if not limb then return end
	parent._limbStore[limb] = {
		OriginalSize = limb.Size,
		OriginalTransparency = limb.Transparency,
		OriginalCanCollide = limb.CanCollide,
		OriginalMassless = limb.Massless,
		SizeConnection = nil,
		CollisionConnection = nil,
	}
end

function PlayerData:restoreLimbProperties(limb)
	local parent = self._parent
	if not limb then return end
	
	if limbExtenderData.SpoofedParts then
		limbExtenderData.SpoofedParts[limb] = nil
	end

	local p = parent._limbStore[limb]
	if not p then return end
	if p.SizeConnection and typeof(p.SizeConnection) == "RBXScriptConnection" then p.SizeConnection:Disconnect() end
	if p.TransparencyConnection and typeof(p.TransparencyConnection) == "RBXScriptConnection" then p.TransparencyConnection:Disconnect() end
	if p.CollisionConnection and typeof(p.CollisionConnection) == "RBXScriptConnection" then p.CollisionConnection:Disconnect() end
	if limb and limb.Parent then
		limb.Size = p.OriginalSize
		limb.Transparency = p.OriginalTransparency
		limb.CanCollide = p.OriginalCanCollide
		limb.Massless = p.OriginalMassless
	end
	parent._limbStore[limb] = nil

	if limbExtenderData.limbs then limbExtenderData.limbs[limb] = nil end
end

function PlayerData:modifyLimbProperties(limb)
	local parent = self._parent
	if not limb then return end
	if parent._limbStore[limb] then return end
	self:saveLimbProperties(limb)
	
	local entry = parent._limbStore[limb]
	local sizeVal = parent._settings.LIMB_SIZE or DEFAULTS.LIMB_SIZE
	
	-- [[ WALL SHAPE CALCULATION ]]
	local newSize = Vector3.new(sizeVal, sizeVal, sizeVal / 1.35)
	
	local canCollide = parent._settings.LIMB_CAN_COLLIDE
	local transparency = parent._settings.LIMB_TRANSPARENCY

	entry.SizeConnection = watchProperty(limb, "Size", function(l)
		l.Size = newSize
	end)
	
	entry.TransparencyConnection = watchProperty(limb, "Transparency", function(l)
		l.Transparency = transparency
	end)
	
	entry.CollisionConnection = watchProperty(limb, "CanCollide", function(l)
		l.CanCollide = canCollide
	end)

	if limb and limb.Parent then
		limb.Size = newSize
		limb.Transparency = parent._settings.LIMB_TRANSPARENCY
		limb.CanCollide = canCollide
		if parent._settings.TARGET_LIMB ~= "HumanoidRootPart" then
			limb.Massless = true
		end
	end

	if limbExtenderData.limbs then limbExtenderData.limbs[limb] = parent._limbStore[limb] end
end

function PlayerData:spoofSize(part)
	if not part then return end
	if limbExtenderData.SpoofedParts then
		limbExtenderData.SpoofedParts[part] = part.Size 
	end
end

function PlayerData:setupCharacter(char)
	local parent = self._parent
	if not char or not parent then return end
	if not self.player then return end

	if typeof(self.player.GetPropertyChangedSignal) == "function" then
		local sig = self.player:GetPropertyChangedSignal("Team")
		if sig and typeof(sig.Connect) == "function" then
			self.conns:Connect(sig, function()
				if self._destroyed then return end
				local plr = self.player
				if not plr then return end
				self:Destroy()
				if parent and parent._playerTable and typeof(parent._playerTable) == "table" then
					parent._playerTable[plr.Name] = PlayerData.new(parent, plr)
				end
			end, ("Player_%s_TeamChanged"):format(self.player.Name))
		end
	end

	if parent:_isTeam(self.player) then return end

	local humanoid = char:WaitForChild("Humanoid", 10)
	if not humanoid or humanoid.Health <= 0 then return end

	if self.PartStreamable and typeof(self.PartStreamable.Destroy) == "function" then
		self.PartStreamable:Destroy()
		self.PartStreamable = nil
	end

	if parent._Streamable and typeof(parent._Streamable.new) == "function" then
		self.PartStreamable = parent._Streamable.new(char, parent._settings.TARGET_LIMB)
		if self.PartStreamable and typeof(self.PartStreamable.Observe) == "function" then
			self.PartStreamable:Observe(function(part, trove)
				if self._destroyed or not part then return end

				self:spoofSize(part)
				self:modifyLimbProperties(part)

				if parent._settings.USE_HIGHLIGHT then
					if not self.highlight then
						self.highlight = makeHighlight(parent._settings)
					end
					self.highlight.Adornee = part
				end

				if self.player and typeof(self.player.CharacterRemoving) == "RBXScriptSignal" then
					self.conns:Connect(self.player.CharacterRemoving, function()
						self:restoreLimbProperties(part)
					end, ("Player_%s_CharacterRemoving_%s"):format(self.player.Name, tostring(part)))
				end

				local deathEvent = parent._settings.RESET_LIMB_ON_DEATH2 and humanoid.HealthChanged or humanoid.Died
				if deathEvent and typeof(deathEvent.Connect) == "function" then
					self.conns:Connect(deathEvent, function(hp)
						if not hp or (type(hp) == "number" and hp <= 0) or humanoid.Health <= 0 then
							self:restoreLimbProperties(part)
						end
					end, ("Player_%s_Death_%s"):format(self.player.Name, tostring(part)))
				end

				if trove and typeof(trove.Add) == "function" then
					self.conns:Add(function()
						self:restoreLimbProperties(part)
					end, ("Player_%s_TroveRestore_%s"):format(self.player.Name, tostring(part)))
				end
			end)
		end
	end
end

function PlayerData:onCharacter(char)
	if not char then return end
	if self._charDelay then task.cancel(self._charDelay); self._charDelay = nil end

	self._charDelay = task.delay(0.1, function()
		if self._destroyed then return end
		if self._parent._settings.FORCEFIELD_CHECK then
			local ff = char:FindFirstChildOfClass("ForceField")
			if ff then
				self.conns:Connect(ff.Destroying, function() self:setupCharacter(char) end, ("Player_%s_ForceField_%s"):format(self.player.Name, tostring(char)))
				return
			end
		end
		self:setupCharacter(char)
	end)
end

function PlayerData:Destroy()
	if self._destroyed then return end
	self._destroyed = true
	if self.conns then self.conns:DisconnectAll(); self.conns:Destroy(); self.conns = nil end
	if self.highlight then self.highlight:Destroy(); self.highlight = nil end
	if self.PartStreamable then self.PartStreamable:Destroy(); self.PartStreamable = nil end
	if self._charDelay then task.cancel(self._charDelay); self._charDelay = nil end
	setmetatable(self, nil)
end

local LimbExtender = {}
LimbExtender.__index = LimbExtender

function LimbExtender.new(userSettings)
	local self = setmetatable({
		_settings = mergeSettings(userSettings),
		_playerTable = limbExtenderData.playerTable or {},
		_limbStore = limbExtenderData.limbs or {},
		_Streamable = limbExtenderData.Streamable,
		_CAU = limbExtenderData.CAU,
		_connections = ConnectionManager.new(),
		_running = limbExtenderData.running or false,
		_destroyed = false,
	}, LimbExtender)

	limbExtenderData.playerTable = self._playerTable
	limbExtenderData.limbs = self._limbStore
	limbExtenderData.terminateOldProcess = function() self:Destroy() end

	self._Streamable = loadstring(game:HttpGet('https://raw.githubusercontent.com/AAPVdev/modules/refs/heads/main/Streamable.lua'))()
	
    if self._settings.LISTEN_FOR_INPUT then
		self._CAU = loadstring(game:HttpGet('https://raw.githubusercontent.com/AAPVdev/modules/refs/heads/main/ContextActionUtility.lua'))()
		self._CAU:BindAction("LimbExtenderToggle", function(_, state) if state == Enum.UserInputState.Begin then self:Toggle() end end, self._settings.MOBILE_BUTTON, Enum.KeyCode[self._settings.TOGGLE])
	end
	return self
end

function LimbExtender:_isTeam(player)
	return self._settings.TEAM_CHECK and localPlayer and localPlayer.Team ~= nil and player.Team == localPlayer.Team
end

function LimbExtender:Start()
	if self._running then return end
	self._running = true
	limbExtenderData.running = true
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= localPlayer then self._playerTable[p.Name] = PlayerData.new(self, p) end
	end
	self._connections:Connect(Players.PlayerAdded, function(p) self._playerTable[p.Name] = PlayerData.new(self, p) end, "PlayerAdded")
	self._connections:Connect(Players.PlayerRemoving, function(p) if self._playerTable[p.Name] then self._playerTable[p.Name]:Destroy(); self._playerTable[p.Name] = nil end end, "PlayerRemoving")
end

function LimbExtender:Stop()
	self._running = false
	limbExtenderData.running = false
	if limbExtenderData.SpoofedParts then for k in pairs(limbExtenderData.SpoofedParts) do limbExtenderData.SpoofedParts[k] = nil end end
	for i, pd in pairs(self._playerTable) do pd:Destroy(); self._playerTable[i] = nil end
end

function LimbExtender:Toggle() if self._running then self:Stop() else self:Start() end end

function LimbExtender:Destroy()
	self:Stop()
	if self._connections then self._connections:DisconnectAll(); self._connections:Destroy() end
    if self._CAU then self._CAU:UnbindAction("LimbExtenderToggle") end
end

return setmetatable({}, { __call = function(_, s) return LimbExtender.new(s) end, __index = LimbExtender })
