-- [[ OPTIMIZED HITBOX EXPANDER - DUAL TARGET EDITION ]]
-- Focus: Raw Performance, Low Memory.
-- Features: RootPart Resizing + Fake Head Hitbox (Visuals stay normal).

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- [[ CONFIGURATION ]]
local SETTINGS = {
	TOGGLE_KEY = Enum.KeyCode.L,
	TRANSPARENCY = 0.9,
	
	-- Specific sizes for parts
	ROOT_SIZE = Vector3.new(4, 2, 2.5),
	HEAD_SIZE = Vector3.new(3, 2, 2.5),
}

-- [[ GLOBAL STATE MANAGEMENT ]]
local Data = getgenv().HitboxOptimized
if Data and Data.Cleanup then
	Data.Cleanup()
end

Data = {
	Connections = {}, 
	Originals = {}, -- Stores original sizes for restoration
	FakeParts = {}, -- Stores the fake head parts to destroy later
	Running = false,
}
getgenv().HitboxOptimized = Data

-- [[ HELPER FUNCTIONS ]]

-- 1. RESTORE: Returns parts to normal when script stops
local function RestoreLimb(part)
	if not part then return end
	
	-- If it's a fake part we made, destroy it
	if Data.FakeParts[part] then
		part:Destroy()
		Data.FakeParts[part] = nil
		return
	end

	-- If it's a real part we resized, reset it
	local original = Data.Originals[part]
	if original then
		part.Size = original
		part.Transparency = 0 -- Assuming default is opaque, or save specific if needed
		part.CanCollide = true
		Data.Originals[part] = nil
	end
end

-- 2. CREATE FAKE HEAD: Welds a hitbox to the head without resizing the real head
local function CreateFakeHead(character, realHead)
	if not Data.Running then return end
	if character:FindFirstChild("HitboxHead") then return end -- Already exists

	local fakeHead = Instance.new("Part")
	fakeHead.Name = "HitboxHead" -- Unique name to avoid conflicts
	fakeHead.Size = SETTINGS.HEAD_SIZE
	fakeHead.Transparency = SETTINGS.TRANSPARENCY
	fakeHead.CanCollide = false
	fakeHead.Massless = true
	fakeHead.Material = Enum.Material.Plastic
	fakeHead.Color = Color3.fromRGB(255, 0, 0) -- Visual debug (red), relies on transparency
	
	-- Initial Position
	fakeHead.CFrame = realHead.CFrame

	-- Weld to real head so it moves with animations
	local weld = Instance.new("WeldConstraint")
	weld.Part0 = realHead
	weld.Part1 = fakeHead
	weld.Parent = fakeHead

	-- IMPORTANT: Parent to Character so damage scripts register it as part of the enemy
	fakeHead.Parent = character
	
	-- Track it for cleanup
	Data.FakeParts[fakeHead] = true
	
	-- Add a heartbeat connection to ensure it stays attached/correct (Lightweight)
	-- Some games delete "unknown" parts, so we watch it.
	local conn = fakeHead:GetPropertyChangedSignal("Parent"):Connect(function()
		if not fakeHead.Parent then
			Data.FakeParts[fakeHead] = nil
		end
	end)
	table.insert(Data.Connections, conn)
end

-- 3. HOOK ROOT PART: Resizes the actual HRP
local function HookRootPart(part)
	if not part or Data.Originals[part] then return end 

	-- Save original size
	Data.Originals[part] = part.Size

	-- Apply Size
	part.Size = SETTINGS.ROOT_SIZE
	part.Transparency = SETTINGS.TRANSPARENCY
	part.CanCollide = false

	-- Keep it forced (Game fightback loop)
	local conn = part:GetPropertyChangedSignal("Size"):Connect(function()
		if Data.Running and part.Size ~= SETTINGS.ROOT_SIZE then
			part.Size = SETTINGS.ROOT_SIZE
			part.Transparency = SETTINGS.TRANSPARENCY
			part.CanCollide = false
		end
	end)
	
	table.insert(Data.Connections, conn)
end

-- 4. CHARACTER SETUP: Orchestrates the logic per character
local function SetupCharacter(char)
	if not char then return end
	
	-- A. Handle HumanoidRootPart
	task.spawn(function()
		local hrp = char:WaitForChild("HumanoidRootPart", 5)
		if hrp then
			HookRootPart(hrp)
		end
	end)

	-- B. Handle Head (Fake Part Strategy)
	task.spawn(function()
		local head = char:WaitForChild("Head", 5)
		if head then
			CreateFakeHead(char, head)
		end
	end)
end

local function SetupPlayer(plr)
	if plr == LocalPlayer then return end -- Ignore self

	if plr.Character then
		SetupCharacter(plr.Character)
	end

	local conn = plr.CharacterAdded:Connect(function(char)
		task.delay(0.5, SetupCharacter, char) -- Slight delay for mesh loading
	end)
	table.insert(Data.Connections, conn)
end

-- [[ CORE FUNCTIONS ]]

local function Start()
	if Data.Running then return end
	Data.Running = true
	
	for _, plr in ipairs(Players:GetPlayers()) do
		SetupPlayer(plr)
	end

	local conn = Players.PlayerAdded:Connect(SetupPlayer)
	table.insert(Data.Connections, conn)
	
	print("[Hitbox] Enabled")
end

local function Stop()
	Data.Running = false
	
	-- Clear connections
	for _, conn in ipairs(Data.Connections) do
		if conn.Connected then conn:Disconnect() end
	end
	table.clear(Data.Connections)

	-- Restore Real Parts (RootParts)
	for part, _ in pairs(Data.Originals) do
		RestoreLimb(part)
	end
	table.clear(Data.Originals)
	
	-- Destroy Fake Parts (Heads)
	for part, _ in pairs(Data.FakeParts) do
		if part and part.Parent then
			part:Destroy()
		end
	end
	table.clear(Data.FakeParts)
	
	print("[Hitbox] Disabled")
end

local function Toggle()
	if Data.Running then Stop() else Start() end
end

-- [[ INPUT HANDLING
